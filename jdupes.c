/* jdupes (C) 2015-2016 Jody Bruchon <jody@jodybruchon.com>
   Derived from fdupes (C) 1999-2016 Adrian Lopez
   Includes jody_hash (C) 2015-2016 by Jody Bruchon

   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation files
   (the "Software"), to deal in the Software without restriction,
   including without limitation the rights to use, copy, modify, merge,
   publish, distribute, sublicense, and/or sell copies of the Software,
   and to permit persons to whom the Software is furnished to do so,
   subject to the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#ifndef OMIT_GETOPT_LONG
 #include <getopt.h>
#endif
#include <string.h>
#include <errno.h>
#include <libgen.h>
#include "jody_hash.h"
#include "version.h"

/* Optional btrfs support */
#ifdef ENABLE_BTRFS
#define HAVE_BTRFS_IOCTL_H
#endif
#ifdef HAVE_BTRFS_IOCTL_H
#include <sys/types.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <btrfs/ioctl.h>
#endif

/* Detect Windows and modify as needed */
#if defined _WIN32 || defined __CYGWIN__
 #define ON_WINDOWS 1
 #define NO_SYMLINKS 1
 #define NO_PERMS 1
 #ifndef WIN32_LEAN_AND_MEAN
  #define WIN32_LEAN_AND_MEAN
 #endif
 #include <windows.h>
 #include "getino.h"
// #define NO_HARDLINKS 1
#endif

/* Compile out debugging stat counters unless requested */
#ifdef DEBUG
#define DBG(a) a
#else
#define DBG(a)
#endif


/* How many operations to wait before updating progress counters */
#define DELAY_COUNT 512

#define ISFLAG(a,b) ((a & b) == b)
#define SETFLAG(a,b) (a |= b)

/* Behavior modification flags */
static uint_fast32_t flags = 0;
#define F_RECURSE		0x00000001
#define F_HIDEPROGRESS		0x00000002
#define F_DSAMELINE		0x00000004
#define F_FOLLOWLINKS		0x00000008
#define F_DELETEFILES		0x00000010
#define F_EXCLUDEEMPTY		0x00000020
#define F_CONSIDERHARDLINKS	0x00000040
#define F_SHOWSIZE		0x00000080
#define F_OMITFIRST		0x00000100
#define F_RECURSEAFTER		0x00000200
#define F_NOPROMPT		0x00000400
#define F_SUMMARIZEMATCHES	0x00000800
#define F_EXCLUDEHIDDEN		0x00001000
#define F_PERMISSIONS		0x00002000
#define F_HARDLINKFILES		0x00004000
#define F_EXCLUDESIZE		0x00008000
#define F_QUICKCOMPARE		0x00010000
#define F_USEPARAMORDER		0x00020000
#define F_DEDUPEFILES		0x00040000
#define F_DEBUG			0x80000000

typedef enum {
  ORDER_TIME = 0,
  ORDER_NAME
} ordertype_t;

static const char *program_name;

static off_t excludesize = 0;

/* Larger chunk size makes large files process faster but uses more RAM */
#define CHUNK_SIZE 1048576
#define INPUT_SIZE 256
#define PARTIAL_HASH_SIZE 4096

/* Assemble extension string from compile-time options */
static const char *extensions[] = {
	#ifdef ENABLE_BTRFS
	"btrfs",
	#endif
	#ifdef ON_WINDOWS
	"windows",
	#endif
	#ifdef OMIT_GETOPT_LONG
	"nolong",
	#endif
	#ifdef __FAST_MATH__
	"fastmath",
	#endif
	#ifdef NO_FLOAT
	"nofloat",
	#endif
	#ifdef DEBUG
	"debug",
	#endif
	#ifdef SMA_PAGE_SIZE
	"smapage",
	#endif
	#ifdef NO_PERMS
	"noperm",
	#endif
	#ifdef NO_SYMLINKS
	"nosymlink",
	#endif
	#ifdef USE_TREE_REBALANCE
	"rebal",
	#endif
	#ifdef CONSIDER_IMBALANCE
	"ci",
	#endif
	#ifdef BALANCE_THRESHOLD
	"bt",
	#endif
	#ifdef BAL_BIT
	"bb",
	#endif
	NULL
};

/* These used to be functions. This way saves lots of call overhead */
#define getcrcsignature(a) getcrcsignatureuntil(a, 0)
#define getcrcpartialsignature(a) getcrcsignatureuntil(a, PARTIAL_HASH_SIZE)

/* TODO: Cachegrind indicates that size, inode, and device get hammered hard
 * in the checkmatch() code and trigger lots of cache line evictions.
 * Maybe we can compact these into a separate structure to improve speed.
 * Also look into compacting the true/false flags into one integer and see
 * if that improves performance (it'll certainly lower memory usage) */
typedef struct _file {
  char *d_name;
  uint_fast8_t valid_stat; /* Only call stat() once per file (1 = stat'ed) */
  off_t size;
  dev_t device;
  ino_t inode;
  mode_t mode;
#ifndef NO_PERMS
  uid_t uid;
  gid_t gid;
#endif
  time_t mtime;
  unsigned int user_order; /* Order of the originating command-line parameter */
  hash_t crcpartial;
  hash_t crcsignature;
  uint_fast8_t crcpartial_set;  /* 1 = crcpartial is valid */
  uint_fast8_t crcsignature_set;  /* 1 = crcsignature is valid */
  uint_fast8_t hasdupes; /* 1 only if file is first on duplicate chain */
  struct _file *duplicates;
  struct _file *next;
} file_t;

typedef struct _filetree {
  file_t *file;
  struct _filetree *left;
  struct _filetree *right;
#ifdef USE_TREE_REBALANCE
  struct _filetree *parent;
  unsigned int left_weight;
  unsigned int right_weight;
#endif /* USE_TREE_REBALANCE */
} filetree_t;

#ifdef USE_TREE_REBALANCE
static filetree_t *checktree = NULL;
#endif

static uintmax_t filecount = 0; // Required for progress indicator code

/* Hash/compare performance statistics (debug mode) */
#ifdef DEBUG
static unsigned int small_file = 0, partial_hash = 0, partial_to_full = 0, hash_fail = 0;
static uintmax_t comparisons = 0;
static unsigned int left_branch = 0, right_branch = 0;
static unsigned int tree_depth = 0, max_depth = 0;
#endif /* DEBUG */

/* Directory parameter position counter */
static unsigned int user_dir_count = 1;

/* registerfile() direction options */
enum tree_direction { NONE, LEFT, RIGHT };

/***** End definitions, begin code *****/

/*
 * String table allocator
 * A replacement for malloc() for tables of fixed strings
 *
 * Copyright (C) 2015-2016 by Jody Bruchon <jody@jodybruchon.com>
 * Released under The MIT License or GNU GPL v2 (your choice)
 *
 * Included here using the license for this software
 * (Inlined for performance reasons)
 */

/* Must be divisible by uintptr_t */
#ifndef SMA_PAGE_SIZE
#define SMA_PAGE_SIZE 262144
#endif

static void *sma_head = NULL, *sma_free_head = NULL;
static uintptr_t *sma_lastpage = NULL, *sma_free_lastpage = NULL;
static unsigned int sma_pages = 0, sma_free_pages = 0;
static size_t sma_nextfree = sizeof(uintptr_t);
static size_t sma_free_nextfree = sizeof(uintptr_t);
static unsigned int sma_free_count = 0, sma_free_largest = 0;
#ifdef DEBUG
static uintmax_t sma_allocs = 0, sma_frees = 0;
#endif


/*
static void dump_string_table(void)
{
	char *p = sma_head;
	unsigned int i = sizeof(uintptr_t);
	int pg = sma_pages;

	while (pg > 0) {
		while (i < SMA_PAGE_SIZE && *(p+i) == '\0') i++;
		printf("[%16p] (%jd) '%s'\n", p+i, strlen(p+i), p+i);
		i += strlen(p+i);
		if (pg <= 1 && i >= sma_nextfree) return;
		if (i < SMA_PAGE_SIZE) i++;
		else {
			p = (char *)*(uintptr_t *)p;
			pg--;
			i = sizeof(uintptr_t);
		}
		if (p == NULL) return;
	}

	return;
}
*/


static inline void *string_malloc_page(uintptr_t * const lastpage)
{
	uintptr_t * restrict pageptr;

	/* Allocate page and set up pointers at page starts */
	pageptr = (uintptr_t *)malloc(SMA_PAGE_SIZE);
	if (pageptr == NULL) return NULL;
	*pageptr = (uintptr_t)NULL;
	/* Link this page to the previous page */
	*(pageptr + sizeof(uintptr_t)) = (uintptr_t)lastpage;

	/* Link previous page to this page, if applicable */
	if (lastpage != NULL) *lastpage = (uintptr_t)pageptr;

	return (void *)pageptr;
}


static void *string_malloc(size_t len)
{
	uintptr_t *page = (uintptr_t *)sma_lastpage;
	static char *address;

	/* Calling with no actual length is invalid */
	if (len < 1) return NULL;

	/* Align objects where possible */
	if (len & (sizeof(uintptr_t) - 1)) {
		len &= ~(sizeof(uintptr_t) - 1);
		len += sizeof(uintptr_t);
	}
	/* Make room for size prefix */
	len += sizeof(size_t);

	/* Refuse to allocate a space larger than we can store */
	if (len > (unsigned int)(SMA_PAGE_SIZE - sizeof(uintptr_t))) return NULL;

	/* Initialize on first use */
	if (sma_pages == 0) {
		sma_head = string_malloc_page(NULL);
		if (!sma_head) return NULL;
		sma_lastpage = sma_head;
		sma_pages++;
		sma_nextfree = (2 * sizeof(uintptr_t));
		/* Also allocate the free list here */
		sma_free_head = string_malloc_page(NULL);
		if (!sma_free_head) return NULL;
		sma_free_lastpage = sma_free_head;
		sma_free_pages++;
		sma_free_nextfree = sizeof(uintptr_t);
		page = sma_head;
	}

	/* Allocate new pages when objects don't fit anymore */
	if ((sma_nextfree + len) > SMA_PAGE_SIZE) {
		page = string_malloc_page(sma_lastpage);
		if (!page) return NULL;
		sma_lastpage = page;
		sma_pages++;
		sma_nextfree = (2 * sizeof(uintptr_t));
	}

	/* Allocate the space */
	address = (char *)page + sma_nextfree;
	/* Prefix object with its size */
	*(size_t *)address = (size_t)len;
	address += sizeof(size_t);
	sma_nextfree += len;

#ifdef DEBUG
	sma_allocs++;
#endif
	return address;
}


/* Free chunks of memory */
static inline void string_free(const void * restrict addr)
{
	static const char * restrict p;
	int size;

	/* Do nothing on NULL address */
	if (sma_free_head == NULL || addr == NULL) return;

	p = (char *)addr - sizeof(size_t);
	size = *p;

	/* Catch attempts to free something that's too big */
	if (size > (SMA_PAGE_SIZE - (2 * sizeof(uintptr_t)) - sizeof(size_t))) {
		return;
	}

	/* Record largest free object ever seen for optimization
	 * This allows string_malloc() to skip the free list if
	 * there's never been a freed object large enough to hold what
	 * is being allocated. It will not ever shrink. */
	if (size > sma_free_largest) sma_free_largest = size;

	/* Find next free slot and store the freed object */

#ifdef DEBUG
	sma_frees++;
#endif
	return;
}

/* Destroy all allocated pages */
static inline void string_malloc_destroy(void)
{
	static void *cur;
	static uintptr_t *next;

	cur = (void *)sma_head;
	while (sma_pages > 0) {
		next = (uintptr_t *)*(uintptr_t *)cur;
		free(cur);
		cur = (void *)next;
		sma_pages--;
	}
	sma_head = NULL;

	cur = (void *)sma_free_head;
	while (sma_free_pages > 0) {
		next = (uintptr_t *)*(uintptr_t *)cur;
		free(cur);
		cur = (void *)next;
		sma_free_pages--;
	}
	sma_head = NULL;
	return;
}



/* Compare two jody_hashes like memcmp() */
#define CRC_COMPARE(a,b) ((a > b) ? 1:((a == b) ? 0:-1))
#if 0
static inline int crc_cmp(const hash_t hash1, const hash_t hash2)
{
	if (hash1 > hash2) return 1;
	if (hash1 == hash2) return 0;
	/* No need to compare a third time */
	return -1;
}
#endif

/* Print error message. NULL will output "out of memory" and exit */
static void errormsg(const char *message, ...)
{
  va_list ap;

  /* A null pointer means "out of memory" */
  if (message == NULL) {
    fprintf(stderr, "\r%40s\rout of memory\n", "");
    exit(EXIT_FAILURE);
  }

  va_start(ap, message);

  /* Windows will dump the full program path into argv[0] */
#ifndef ON_WINDOWS
  fprintf(stderr, "\r%40s\r%s: ", "", program_name);
#else
  fprintf(stderr, "\r%40s\r%s: ", "", "jdupes");
#endif
  vfprintf(stderr, message, ap);
}


static void escapefilename(char **filename_ptr)
{
  static unsigned int x;
  static unsigned int tx;
  static char tmp[8192];
  static char *filename;
  static size_t sl;

  filename = *filename_ptr;
  sl = strlen(filename);

  for (x = 0, tx = 0; x < sl; x++) {
    if (tx >= 8192) errormsg("escapefilename() path overflow");
    if (strchr("\\ ", filename[x]) != NULL) tmp[tx++] = '\\';
    tmp[tx++] = filename[x];
  }

  tmp[tx] = '\0';

  if (x != tx) {
    //*filename_ptr = realloc(*filename_ptr, strlen(tmp) + 1);
    *filename_ptr = (char *)string_malloc(strlen(tmp) + 1);
    if (*filename_ptr == NULL) errormsg(NULL);
    strcpy(*filename_ptr, tmp);
  }
}


static inline char **cloneargs(const int argc, char **argv)
{
  static int x;
  static char **args;

  args = (char **) string_malloc(sizeof(char*) * argc);
  if (args == NULL) errormsg(NULL);

  for (x = 0; x < argc; x++) {
    args[x] = (char *)string_malloc(strlen(argv[x]) + 1);
    if (args[x] == NULL) errormsg(NULL);
    strcpy(args[x], argv[x]);
  }

  return args;
}


static int findarg(const char * const arg, const int start,
		const int argc, char **argv)
{
  static int x;

  for (x = start; x < argc; x++)
    if (strcmp(argv[x], arg) == 0)
      return x;

  return x;
}

/* Find the first non-option argument after specified option. */
static int nonoptafter(const char *option, const int argc,
		char **oldargv, char **newargv, int optind)
{
  static int x;
  static int targetind;
  static int testind;
  int startat = 1;

  targetind = findarg(option, 1, argc, oldargv);

  for (x = optind; x < argc; x++) {
    testind = findarg(newargv[x], startat, argc, oldargv);
    if (testind > targetind) return x;
    else startat = testind;
  }

  return x;
}


static inline void getfilestats(file_t * const restrict file)
{
  static struct stat s;

  /* Don't stat() the same file more than once */
  if (file->valid_stat == 1) return;
  file->valid_stat = 1;

  if (stat(file->d_name, &s) != 0) {
/* These are already set during file entry initialization */
    /* file->size = -1;
    file->inode = 0;
    file->device = 0;
    file->mtime = 0;
    file->mode = 0;
    file->uid = 0;
    file->gid = 0; */
    return;
  }
  file->size = s.st_size;
  file->device = s.st_dev;
  file->mtime = s.st_mtime;
  file->mode = s.st_mode;
#ifndef NO_PERMS
  file->uid = s.st_uid;
  file->gid = s.st_gid;
#endif
#ifdef ON_WINDOWS
  file->inode = getino(file->d_name);
#else
  file->inode = s.st_ino;
#endif /* ON_WINDOWS */
  return;
}


static void grokdir(const char * const restrict dir,
		file_t * restrict * const restrict filelistp)
{
  DIR *cd;
  file_t * restrict newfile;
#ifndef NO_SYMLINKS
  static struct stat linfo;
#endif
  static struct dirent *dirinfo;
  static uintmax_t progress = 0, dir_progress = 0;
  static int grokdir_level = 0;
  static int delay = DELAY_COUNT;
  static char tempname[8192];

  cd = opendir(dir);
  dir_progress++;
  grokdir_level++;

  if (!cd) {
    errormsg("could not chdir to %s\n", dir);
    return;
  }

  while ((dirinfo = readdir(cd)) != NULL) {
    char * restrict tp = tempname;
    size_t dirlen;
    size_t d_name_len;

    if (strcmp(dirinfo->d_name, ".") && strcmp(dirinfo->d_name, "..")) {
      if (!ISFLAG(flags, F_HIDEPROGRESS)) {
        if (delay >= DELAY_COUNT) {
          delay = 0;
          fprintf(stderr, "\rScanning: %ju files, %ju dirs (in %u specified)",
			  progress, dir_progress, user_dir_count);
        } else delay++;
      }

      /* Assemble the file's full path name, optimized to avoid strcat() */
      dirlen = strlen(dir);
      d_name_len = strlen(dirinfo->d_name);
      memcpy(tp, dir, dirlen+1);
      if (dirlen != 0 && tp[dirlen-1] != '/') {
        tp[dirlen] = '/';
        dirlen++;
      }
      tp += dirlen;
      memcpy(tp, dirinfo->d_name, d_name_len);
      tp += d_name_len;
      *tp = '\0';
      d_name_len++;

      /* Allocate the file_t and the d_name entries in one shot
       * Reusing lastchar (with a +1) saves us a strlen(dir) here */
      newfile = (file_t *)string_malloc(sizeof(file_t) + dirlen + d_name_len + 2);
      if (!newfile) errormsg(NULL);
      else newfile->next = *filelistp;

      newfile->d_name = (char *)newfile + sizeof(file_t);
      newfile->user_order = user_dir_count;
      newfile->size = -1;
      newfile->device = 0;
      newfile->inode = 0;
      newfile->mtime = 0;
      newfile->mode = 0;
#ifndef NO_PERMS
      newfile->uid = 0;
      newfile->gid = 0;
#endif
      newfile->valid_stat = 0;
      newfile->crcsignature_set = 0;
      newfile->crcsignature = 0;
      newfile->crcpartial_set = 0;
      newfile->crcpartial = 0;
      newfile->duplicates = NULL;
      newfile->hasdupes = 0;

      tp = tempname;
      memcpy(newfile->d_name, tp, dirlen + d_name_len);

      if (ISFLAG(flags, F_EXCLUDEHIDDEN)) {
        /* WARNING: Re-used tp here to eliminate a strdup() */
        strcpy(tp, newfile->d_name);
        tp = basename(tp);
        if (tp[0] == '.' && strcmp(tp, ".") && strcmp(tp, "..")) {
          string_free((char *)newfile);
          continue;
        }
      }

      /* Get file information and check for validity */
      getfilestats(newfile);
      if (newfile->size == -1) {
	string_free((char *)newfile);
	continue;
      }

      /* Exclude zero-length files if requested */
      if (!S_ISDIR(newfile->mode) && newfile->size == 0 && ISFLAG(flags, F_EXCLUDEEMPTY)) {
	string_free((char *)newfile);
	continue;
      }

      /* Exclude files below --xsize parameter */
      if (!S_ISDIR(newfile->mode) && ISFLAG(flags, F_EXCLUDESIZE) && newfile->size < excludesize) {
	string_free((char *)newfile);
	continue;
      }

#ifndef NO_SYMLINKS
      /* Get lstat() information */
      if (lstat(newfile->d_name, &linfo) == -1) {
	string_free((char *)newfile);
	continue;
      }
#endif

      /* Optionally recurse directories, including symlinked ones if requested */
      if (S_ISDIR(newfile->mode)) {
#ifndef NO_SYMLINKS
	if (ISFLAG(flags, F_RECURSE) && (ISFLAG(flags, F_FOLLOWLINKS) || !S_ISLNK(linfo.st_mode)))
          grokdir(newfile->d_name, filelistp);
#else
	if (ISFLAG(flags, F_RECURSE))
          grokdir(newfile->d_name, filelistp);
#endif
	string_free((char *)newfile);
      } else {
        /* Add regular files to list, including symlink targets if requested */
#ifndef NO_SYMLINKS
        if (S_ISREG(linfo.st_mode) || (S_ISLNK(linfo.st_mode) && ISFLAG(flags, F_FOLLOWLINKS))) {
#else
        if (S_ISREG(newfile->mode)) {
#endif
	  *filelistp = newfile;
	  filecount++;
          progress++;
	} else {
	  string_free((char *)newfile);
	}
      }
    }
  }

  closedir(cd);

  grokdir_level--;
  if (grokdir_level == 0 && !ISFLAG(flags, F_HIDEPROGRESS)) {
    fprintf(stderr, "\rExamining %ju files, %ju dirs (in %u specified)",
            progress, dir_progress, user_dir_count);
  }
  return;
}

/* Use Jody Bruchon's hash function on part or all of a file */
static hash_t *getcrcsignatureuntil(const file_t * const restrict checkfile,
		const size_t max_read)
{
  off_t fsize;
  /* This is an array because we return a pointer to it */
  static hash_t hash[1];
  static hash_t chunk[(CHUNK_SIZE / sizeof(hash_t))];
  FILE *file;

  /* Get the file size. If we can't read it, bail out early */
  if (checkfile->size == -1) return NULL;
  fsize = checkfile->size;

  /* Do not read more than the requested number of bytes */
  if (max_read > 0 && fsize > (off_t)max_read)
    fsize = (off_t)max_read;

  /* Initialize the hash and file read parameters (with crcpartial skipped)
   *
   * If we already hashed the first chunk of this file, we don't want to
   * wastefully read and hash it again, so skip the first chunk and use
   * the computed hash for that chunk as our starting point.
   *
   * WARNING: We assume max_read is NEVER less than CHUNK_SIZE here! */

  if (checkfile->crcpartial_set) {
    *hash = checkfile->crcpartial;
    /* Don't bother going further if max_read is already fulfilled */
    if (max_read <= CHUNK_SIZE) return hash;
  } else *hash = 0;

  file = fopen(checkfile->d_name, "rb");
  if (file == NULL) {
    errormsg("error opening file %s\n", checkfile->d_name);
    return NULL;
  }

  /* Actually seek past the first chunk if applicable
   * This is part of the crcpartial skip optimization */
  if (checkfile->crcpartial_set) {
    if (!fseeko(file, CHUNK_SIZE, SEEK_SET)) {
      fclose(file);
      errormsg("error seeking in file %s\n", checkfile->d_name);
      return NULL;
    }
    fsize -= CHUNK_SIZE;
  }

  /* Read the file in CHUNK_SIZE chunks until we've read it all. */
  while (fsize > 0) {
    size_t bytes_to_read;

    bytes_to_read = (fsize >= CHUNK_SIZE) ? CHUNK_SIZE : fsize;
    if (fread((void *)chunk, bytes_to_read, 1, file) != 1) {
      errormsg("error reading from file %s\n", checkfile->d_name);
      fclose(file);
      return NULL;
    }

    *hash = jody_block_hash(chunk, *hash, bytes_to_read);
    if ((off_t)bytes_to_read > fsize) break;
    else fsize -= (off_t)bytes_to_read;
  }

  fclose(file);

  return hash;
}


static inline void purgetree(filetree_t * const restrict tree)
{
  if (tree->left != NULL) purgetree(tree->left);
  if (tree->right != NULL) purgetree(tree->right);
  string_free(tree);
}


static inline void registerfile(filetree_t * restrict * const restrict nodeptr,
		const enum tree_direction d, file_t * const restrict file)
{
	filetree_t * restrict branch;

	/* Allocate and initialize a new node for the file */
	branch = (filetree_t *)string_malloc(sizeof(filetree_t));
	if (branch == NULL) errormsg(NULL);
	branch->file = file;
	branch->left = NULL;
	branch->right = NULL;
#ifdef USE_TREE_REBALANCE
	branch->left_weight = 0;
	branch->right_weight = 0;

	/* Attach the new node to the requested branch and the parent */
	switch (d) {
		case LEFT:
			branch->parent = *nodeptr;
			(*nodeptr)->left = branch;
			(*nodeptr)->left_weight++;
			break;
		case RIGHT:
			branch->parent = *nodeptr;
			(*nodeptr)->right = branch;
			(*nodeptr)->right_weight++;
			break;
		case NONE:
			/* For the root of the tree only */
			branch->parent = NULL;
			*nodeptr = branch;
			break;
	}

	/* Propagate weights up the tree */
	while (branch->parent != NULL) {
		filetree_t * restrict up;

		up = branch->parent;
		if (up->left == branch) up->left_weight++;
		else if (up->right == branch) up->right_weight++;
		else {
			errormsg("Internal error: file tree linkage is broken\n");
			exit(EXIT_FAILURE);
		}
		branch = up;
	}
#else /* USE_TREE_REBALANCE */
	/* Attach the new node to the requested branch and the parent */
	switch (d) {
		case LEFT:
			(*nodeptr)->left = branch;
			break;
		case RIGHT:
			(*nodeptr)->right = branch;
			break;
		case NONE:
			/* For the root of the tree only */
			*nodeptr = branch;
			break;
	}

#endif /* USE_TREE_REBALANCE */

	return;
}


/* Experimental tree rebalance code. This slows things down in testing
 * but may be more useful in the future. Pass -DUSE_TREE_REBALANCE
 * to try it. */
#ifdef USE_TREE_REBALANCE

/* How much difference to ignore when considering a rebalance */
#ifndef BALANCE_THRESHOLD
#define BALANCE_THRESHOLD 4
#endif
#ifndef BAL_BIT
#define BAL_BIT 0x2000
#endif

/* Rebalance the file tree to reduce search depth */
static inline void rebalance_tree(filetree_t * const tree)
{
	filetree_t * restrict promote;
	filetree_t * restrict demote;
	int difference, direction;
#ifdef CONSIDER_IMBALANCE
	int l, r, imbalance;
#endif

	if (!tree) return;

	/* Rebalance all children first */
	if (tree->left_weight > BALANCE_THRESHOLD) rebalance_tree(tree->left);
	if (tree->right_weight > BALANCE_THRESHOLD) rebalance_tree(tree->right);

	/* If weights are within a certain threshold, do nothing */
	direction = tree->right_weight - tree->left_weight;
	difference = direction;
	if (difference < 0) difference = -difference;
	if (difference <= BALANCE_THRESHOLD) return;

	/* Determine if a tree rotation will help, and do it if so */
	if (direction > 0) {
#ifdef CONSIDER_IMBALANCE
		l = tree->right->left_weight + tree->right_weight;
		r = tree->right->right_weight;
		imbalance = l - r;
		if (imbalance < 0) imbalance = -imbalance;
		/* Don't rotate if imbalance will increase */
		if (imbalance >= difference) return;
#endif /* CONSIDER_IMBALANCE */

		/* Rotate the right node up one level */
		promote = tree->right;
		demote = tree;
		/* Attach new parent's left tree to old parent */
		demote->right = promote->left;
		demote->right_weight = promote->left_weight;
		/* Attach old parent to new parent */
		promote->left = demote;
		promote->left_weight = demote->left_weight + demote->right_weight + 1;
		/* Reconnect parent linkages */
		promote->parent = demote->parent;
		if (demote->right) demote->right->parent = demote;
		demote->parent = promote;
		if (promote->parent == NULL) checktree = promote;
		else if (promote->parent->left == demote) promote->parent->left = promote;
		else promote->parent->right = promote;
		return;
	} else if (direction < 0) {
#ifdef CONSIDER_IMBALANCE
		r = tree->left->right_weight + tree->left_weight;
		l = tree->left->left_weight;
		imbalance = r - l;
		if (imbalance < 0) imbalance = -imbalance;
		/* Don't rotate if imbalance will increase */
		if (imbalance >= difference) return;
#endif /* CONSIDER_IMBALANCE */

		/* Rotate the left node up one level */
		promote = tree->left;
		demote = tree;
		/* Attach new parent's right tree to old parent */
		demote->left = promote->right;
		demote->left_weight = promote->right_weight;
		/* Attach old parent to new parent */
		promote->right = demote;
		promote->right_weight = demote->right_weight + demote->left_weight + 1;
		/* Reconnect parent linkages */
		promote->parent = demote->parent;
		if (demote->left) demote->left->parent = demote;
		demote->parent = promote;
		if (promote->parent == NULL) checktree = promote;
		else if (promote->parent->left == demote) promote->parent->left = promote;
		else promote->parent->right = promote;
		return;

	}

	/* Fall through */
	return;
}

#endif /* USE_TREE_REBALANCE */


static file_t **checkmatch(filetree_t * restrict tree,
		file_t * const restrict file)
{
  int cmpresult = 0;
  const hash_t * restrict crcsignature;

  /* If device and inode fields are equal one of the files is a
   * hard link to the other or the files have been listed twice
   * unintentionally. We don't want to flag these files as
   * duplicates unless the user specifies otherwise. */

  /* Count the total number of comparisons requested */
  DBG(comparisons++;)

/* If considering hard linked files as duplicates, they are
 * automatically duplicates without being read further since
 * they point to the exact same inode. If we aren't considering
 * hard links as duplicates, we just return NULL. */
#ifndef NO_HARDLINKS
  if ((file->inode ==
      tree->file->inode) && (file->device ==
      tree->file->device)) {
    if (ISFLAG(flags, F_CONSIDERHARDLINKS)) return &tree->file;
    else return NULL;
  }
#endif

  /* Exclude files that are not the same size */
  if (file->size < tree->file->size) cmpresult = -1;
  else if (file->size > tree->file->size) cmpresult = 1;
  /* Exclude files by permissions if requested */
  else if (ISFLAG(flags, F_PERMISSIONS) &&
            (file->mode != tree->file->mode
#ifndef NO_PERMS
            || file->uid != tree->file->uid
            || file->gid != tree->file->gid
#endif
	    )) cmpresult = -1;
  else {
    /* Attempt to exclude files quickly with partial file hashing */
    DBG(partial_hash++;)
    if (tree->file->crcpartial_set == 0) {
      crcsignature = getcrcpartialsignature(tree->file);
      if (crcsignature == NULL) {
        errormsg("cannot read file %s\n", tree->file->d_name);
        return NULL;
      }

      tree->file->crcpartial = *crcsignature;
      tree->file->crcpartial_set = 1;
    }

    if (file->crcpartial_set == 0) {
      crcsignature = getcrcpartialsignature(file);
      if (crcsignature == NULL) {
        errormsg("cannot read file %s\n", file->d_name);
        return NULL;
      }

      file->crcpartial = *crcsignature;
      file->crcpartial_set = 1;
    }

    cmpresult = CRC_COMPARE(file->crcpartial, tree->file->crcpartial);

    if (file->size <= PARTIAL_HASH_SIZE) {
      /* crcpartial = crcsignature if file is small enough */
      if (file->crcsignature_set == 0) {
        file->crcsignature = file->crcpartial;
        file->crcsignature_set = 1;
        DBG(small_file++;)
      }
      if (tree->file->crcsignature_set == 0) {
        tree->file->crcsignature = tree->file->crcpartial;
        tree->file->crcsignature_set = 1;
        DBG(small_file++;)
      }
    } else if (cmpresult == 0) {
      /* If partial match was correct, perform a full file hash match */
      if (tree->file->crcsignature_set == 0) {
	crcsignature = getcrcsignature(tree->file);
	if (crcsignature == NULL) return NULL;

	tree->file->crcsignature = *crcsignature;
        tree->file->crcsignature_set = 1;
      }

      if (file->crcsignature_set == 0) {
	crcsignature = getcrcsignature(file);
	if (crcsignature == NULL) return NULL;

	file->crcsignature = *crcsignature;
	file->crcsignature_set = 1;
      }

      /* Full file hash comparison */
      cmpresult = CRC_COMPARE(file->crcsignature, tree->file->crcsignature);

    }
  }

  if (cmpresult < 0) {
    if (tree->left != NULL) {
      DBG(left_branch++; tree_depth++;)
      return checkmatch(tree->left, file);
    } else {
      registerfile(&tree, LEFT, file);
      DBG(if (max_depth < tree_depth) max_depth = tree_depth; tree_depth = 0;)
      return NULL;
    }
  } else if (cmpresult > 0) {
    if (tree->right != NULL) {
      DBG(right_branch++; tree_depth++;)
      return checkmatch(tree->right, file);
    } else {
      registerfile(&tree, RIGHT, file);
      DBG(if (max_depth < tree_depth) max_depth = tree_depth; tree_depth = 0;)
      return NULL;
    }
  } else {
    /* All compares matched */
    DBG(partial_to_full++;)
    DBG(if (max_depth < tree_depth) max_depth = tree_depth; tree_depth = 0;)
    return &tree->file;
  }
  /* Fall through - should never be reached */
  return NULL;
}


/* Do a byte-by-byte comparison in case two different files produce the
   same signature. Unlikely, but better safe than sorry. */
static inline int confirmmatch(FILE * const restrict file1, FILE * const restrict file2)
{
  static char c1[CHUNK_SIZE];
  static char c2[CHUNK_SIZE];
  static size_t r1;
  static size_t r2;

  fseek(file1, 0, SEEK_SET);
  fseek(file2, 0, SEEK_SET);

  do {
    r1 = fread(c1, sizeof(char), CHUNK_SIZE, file1);
    r2 = fread(c2, sizeof(char), CHUNK_SIZE, file2);

    if (r1 != r2) return 0; /* file lengths are different */
    if (memcmp (c1, c2, r1)) return 0; /* file contents are different */
  } while (r2);

  return 1;
}

static void summarizematches(const file_t * restrict files)
{
  unsigned int numsets = 0;
#ifdef NO_FLOAT
  off_t numbytes = 0;
#else
  double numbytes = 0.0;
#endif /* NO_FLOAT */
  int numfiles = 0;
  file_t *tmpfile;

  while (files != NULL) {
    if (files->hasdupes) {
      numsets++;
      tmpfile = files->duplicates;
      while (tmpfile != NULL) {
	numfiles++;
	numbytes += files->size;
	tmpfile = tmpfile->duplicates;
      }
    }
    files = files->next;
  }

  if (numsets == 0)
    printf("No duplicates found.\n");
  else
  {
    printf("%d duplicate files (in %d sets), occupying ", numfiles, numsets);
#ifdef NO_FLOAT
    if (numbytes < 1000) printf("%jd byte%c\n", (intmax_t)numbytes, (numbytes != 1) ? 's' : ' ');
    else if (numbytes <= 1000000) printf("%jd KB\n", (intmax_t)(numbytes / 1000));
    else printf("%jd MB\n", (intmax_t)(numbytes / 1000000));
#else
    if (numbytes < 1000.0) printf("%.0f bytes\n", numbytes);
    else if (numbytes <= (1000.0 * 1000.0)) printf("%.1f KB\n", numbytes / 1000.0);
    else printf("%.1f MB\n", numbytes / (1000.0 * 1000.0));
#endif /* NO_FLOAT */
  }
}


static void printmatches(file_t * restrict files)
{
  file_t * restrict tmpfile;

  while (files != NULL) {
    if (files->hasdupes) {
      if (!ISFLAG(flags, F_OMITFIRST)) {
	if (ISFLAG(flags, F_SHOWSIZE)) printf("%jd byte%c each:\n", (intmax_t)files->size,
	 (files->size != 1) ? 's' : ' ');
	if (ISFLAG(flags, F_DSAMELINE)) escapefilename(&files->d_name);
	printf("%s%c", files->d_name, ISFLAG(flags, F_DSAMELINE)?' ':'\n');
      }
      tmpfile = files->duplicates;
      while (tmpfile != NULL) {
	if (ISFLAG(flags, F_DSAMELINE)) escapefilename(&tmpfile->d_name);
	printf("%s%c", tmpfile->d_name, ISFLAG(flags, F_DSAMELINE)?' ':'\n');
	tmpfile = tmpfile->duplicates;
      }
      printf("\n");

    }

    files = files->next;
  }
}

unsigned int get_max_dupes(file_t *files, unsigned int *max, unsigned int *n_files) {
  file_t *curdupe;
  unsigned int n_dupes;
  unsigned int groups = 0;

  *max = 0;
  if (n_files)
    *n_files = 0;

  while (files) {
    if (files->hasdupes) {
      groups++;
      if (files->size && n_files)
        (*n_files)++;

      n_dupes = 1;

      for (curdupe = files->duplicates; curdupe; curdupe = curdupe->duplicates)
        n_dupes++;

      if (n_dupes > *max)
        *max = n_dupes;

    }

    files = files->next;
  }
  return groups;
}

#ifdef HAVE_BTRFS_IOCTL_H
static char *dedupeerrstr(int err) {
  static char buf[1024];

  if (err == BTRFS_SAME_DATA_DIFFERS) {
    return "BTRFS_SAME_DATA_DIFFERS (data modified in the meantime?)";
  } else if (err < 0) {
    return strerror(-err);
  } else {
    snprintf(buf, sizeof(buf), "Unknown error %d", err);
    buf[sizeof(buf)-1] = '\0';
    return buf;
  }
}

void dedupefiles(file_t *files)
{
  struct btrfs_ioctl_same_args *same;
  char **dupe_filenames; /* maps to same->info indices */

  file_t *curfile;
  unsigned int n_dupes, max_dupes, cur_info;
  unsigned int cur_file = 0, max_files;

  int fd;
  int ret, status;

  get_max_dupes(files, &max_dupes, &max_files);
  same = calloc(sizeof(struct btrfs_ioctl_same_args) +
                sizeof(struct btrfs_ioctl_same_extent_info) * max_dupes, 1);
  dupe_filenames = malloc(max_dupes * sizeof(char *));
  if (!same || !dupe_filenames) {
    errormsg("out of memory\n");
    exit(EXIT_FAILURE);
  }

  while (files) {
    if (files->hasdupes && files->size) {
      cur_file++;
      if (!ISFLAG(flags, F_HIDEPROGRESS)) {
        fprintf(stderr, "\rDedupe [%u/%u] %u%% ", cur_file, max_files,
            cur_file*100 / max_files);
      }

      cur_info = 0;
      for (curfile = files->duplicates; curfile; curfile = curfile->duplicates) {
          dupe_filenames[cur_info] = curfile->d_name;
          fd = open(curfile->d_name, O_RDONLY);
          if (fd == -1) {
            errormsg("Unable to open(\"%s\", O_RDONLY): %s\n",
              curfile->d_name, strerror(errno));
            continue;
          }

          same->info[cur_info].fd = fd;
          same->info[cur_info].logical_offset = 0;
          cur_info++;
      }
      n_dupes = cur_info;

      same->logical_offset = 0;
      same->length = files->size;
      same->dest_count = n_dupes;

      fd = open(files->d_name, O_RDONLY);
      if (fd == -1) {
        errormsg("Unable to open(\"%s\", O_RDONLY): %s\n", files->d_name,
          strerror(errno));
        goto cleanup;
      }

      ret = ioctl(fd, BTRFS_IOC_FILE_EXTENT_SAME, same);
      if (close(fd) == -1)
        errormsg("Unable to close(\"%s\"): %s\n", files->d_name, strerror(errno));

      if (ret == -1) {
        errormsg("ioctl(\"%s\", BTRFS_IOC_FILE_EXTENT_SAME, [%u files]): %s\n",
          files->d_name, n_dupes, strerror(errno));
        goto cleanup;
      }

      for (cur_info = 0; cur_info < n_dupes; cur_info++) {
        if ((status = same->info[cur_info].status) != 0) {
          errormsg("Couldn't dedupe %s => %s: %s\n", files->d_name,
            dupe_filenames[cur_info], dedupeerrstr(status));
        }
      }

cleanup:
      for (cur_info = 0; cur_info < n_dupes; cur_info++) {
        if (close(same->info[cur_info].fd) == -1) {
          errormsg("Unable to close(\"%s\"): %s", dupe_filenames[cur_info],
            strerror(errno));
        }
      }

    } /* has dupes */

    files = files->next;
  }

  if (!ISFLAG(flags, F_HIDEPROGRESS))
    fprintf(stderr, "\r%40s\r", " ");
  free(same);
  free(dupe_filenames);
}
#endif

static void deletefiles(file_t *files, int prompt, FILE *tty)
{
  unsigned int counter, groups;
  unsigned int curgroup = 0;
  file_t *tmpfile;
  file_t **dupelist;
  int *preserve;
  char *preservestr;
  char *token;
  char *tstr;
  unsigned int number, sum, max, x;
  size_t i;

  groups = get_max_dupes(files, &max, NULL);

  max++;

  dupelist = (file_t**) malloc(sizeof(file_t*) * max);
  preserve = (int*) malloc(sizeof(int) * max);
  preservestr = (char*) malloc(INPUT_SIZE);

  if (!dupelist || !preserve || !preservestr) errormsg(NULL);

  while (files) {
    if (files->hasdupes) {
      curgroup++;
      counter = 1;
      dupelist[counter] = files;

      if (prompt) printf("[%u] %s\n", counter, files->d_name);

      tmpfile = files->duplicates;

      while (tmpfile) {
	dupelist[++counter] = tmpfile;
	if (prompt) printf("[%u] %s\n", counter, tmpfile->d_name);
	tmpfile = tmpfile->duplicates;
      }

      if (prompt) printf("\n");

      /* preserve only the first file */
      if (!prompt) {
        preserve[1] = 1;
        for (x = 2; x <= counter; x++) preserve[x] = 0;
      } else do {
        /* prompt for files to preserve */
	printf("Set %u of %u: keep which files? (1 - %u, [a]ll)",
          curgroup, groups, counter);
	if (ISFLAG(flags, F_SHOWSIZE)) printf(" (%ju byte%c each)", (uintmax_t)files->size,
	  (files->size != 1) ? 's' : ' ');
	printf(": ");
	fflush(stdout);

	if (!fgets(preservestr, INPUT_SIZE, tty))
	  preservestr[0] = '\n'; /* treat fgets() failure as if nothing was entered */

	i = strlen(preservestr) - 1;

        /* tail of buffer must be a newline */
	while (preservestr[i]!='\n') {
	  tstr = (char*)
	    realloc(preservestr, strlen(preservestr) + 1 + INPUT_SIZE);
	  if (!tstr) errormsg(NULL);

	  preservestr = tstr;
	  if (!fgets(preservestr + i + 1, INPUT_SIZE, tty))
	  {
	    preservestr[0] = '\n'; /* treat fgets() failure as if nothing was entered */
	    break;
	  }
	  i = strlen(preservestr)-1;
	}

	for (x = 1; x <= counter; x++) preserve[x] = 0;

	token = strtok(preservestr, " ,\n");

	while (token != NULL) {
	  if (*token == 'a' || *token == 'A')
	    for (x = 0; x <= counter; x++) preserve[x] = 1;

	  number = 0;
	  sscanf(token, "%u", &number);
	  if (number > 0 && number <= counter) preserve[number] = 1;

	  token = strtok(NULL, " ,\n");
	}

	for (sum = 0, x = 1; x <= counter; x++) sum += preserve[x];
      } while (sum < 1); /* save at least one file */

      printf("\n");

      for (x = 1; x <= counter; x++) {
	if (preserve[x])
	  printf("   [+] %s\n", dupelist[x]->d_name);
	else {
	  if (remove(dupelist[x]->d_name) == 0) {
	    printf("   [-] %s\n", dupelist[x]->d_name);
	  } else {
	    printf("   [!] %s ", dupelist[x]->d_name);
	    printf("-- unable to delete file!\n");
	  }
	}
      }
      printf("\n");
    }

    files = files->next;
  }

  free(dupelist);
  free(preserve);
  free(preservestr);
}


/* Unused
static inline int sort_pairs_by_arrival(file_t *f1, file_t *f2)
{
  if (f2->duplicates != 0) return 1;

  return -1;
}
*/


static int sort_pairs_by_param_order(file_t *f1, file_t *f2)
{
  if (!ISFLAG(flags, F_USEPARAMORDER)) return 0;
  if (f1->user_order < f2->user_order) return -1;
  if (f1->user_order > f2->user_order) return 1;
  return 0;
}


static int sort_pairs_by_mtime(file_t *f1, file_t *f2)
{
  int po = sort_pairs_by_param_order(f1, f2);

  if (po != 0) return po;

  if (f1->mtime < f2->mtime) return -1;
  else if (f1->mtime > f2->mtime) return 1;

  return 0;
}


#define IS_NUM(a) (((a >= '0') && (a <= '9')) ? 1 : 0)
static inline int numeric_sort(const char * restrict c1,
		const char * restrict c2)
{
	int len1 = 0, len2 = 0;
	int precompare = 0;

	/* Numerically correct sort */
	while (*c1 != '\0' && *c2 != '\0') {
		/* Reset string length counters */
		len1 = 0; len2 = 0;

		/* Skip all sequences of zeroes */
		while (*c1 == '0') {
			len1++;
			c1++;
		}
		while (*c2 == '0') {
			len2++;
			c2++;
		}

		/* If both chars are numeric, do a numeric comparison */
		if (IS_NUM(*c1) && IS_NUM(*c2)) {
			precompare = 0;

			/* Scan numbers and get preliminary results */
			while (IS_NUM(*c1) && IS_NUM(*c2)) {
				if (*c1 < *c2) precompare = -1;
				if (*c1 > *c2) precompare = 1;
				len1++; len2++;
				c1++; c2++;

				/* Skip remaining digit pairs after any
				 * difference is found */
				if (precompare != 0) {
					while (IS_NUM(*c1) && IS_NUM(*c2)) {
						len1++; len2++;
						c1++; c2++;
					}
					break;
				}
			}

			/* One numeric and one non-numeric means the
			 * numeric one is larger and sorts later */
			if (IS_NUM(*c1) ^ IS_NUM(*c2)) {
				if (IS_NUM(*c1)) return 1;
				else return -1;
			}

			/* If the last test fell through, numbers are
			 * of equal length. Use the precompare result
			 * as the result for this number comparison. */
			if (precompare != 0) return precompare;
		}

		/* Do normal comparison */
		if (*c1 == *c2) {
			c1++; c2++;
			len1++; len2++;
		/* Put symbols and spaces after everything else */
		} else if (*c2 < '.' && *c1 >= '.') return -1;
		else if (*c1 < '.' && *c2 >= '.') return 1;
		/* Normal strcmp() style compare */
		else if (*c1 > *c2) return 1;
		else return -1;
	}

	/* Longer strings generally sort later */
	if (len1 < len2) return -1;
	if (len1 > len2) return 1;
	/* Normal strcmp() style comparison */
	if (*c1 == '\0' && *c2 != '\0') return -1;
	if (*c1 != '\0' && *c2 == '\0') return 1;

	/* Fall through: the strings are equal */
	return 0;
}


static int sort_pairs_by_filename(file_t *f1, file_t *f2)
{
  int po = sort_pairs_by_param_order(f1, f2);

  if (po != 0) return po;

  return numeric_sort(f1->d_name, f2->d_name);
}


static void registerpair(file_t **matchlist, file_t *newmatch,
		  int (*comparef)(file_t *f1, file_t *f2))
{
  file_t *traverse;
  file_t *back;

  (*matchlist)->hasdupes = 1;
  back = NULL;
  traverse = *matchlist;

  /* FIXME: This needs to be changed! As it currently stands, the compare
   * function only runs on a pair as it is registered and future pairs can
   * mess up the sort order. A separate sorting function should happen before
   * the dupe chain is acted upon rather than while pairs are registered. */
  while (traverse) {
    if (comparef(newmatch, traverse) <= 0) {
      newmatch->duplicates = traverse;

      if (!back) {
	*matchlist = newmatch; /* update pointer to head of list */
	newmatch->hasdupes = 1;
	traverse->hasdupes = 0; /* flag is only for first file in dupe chain */
      } else back->duplicates = newmatch;

      break;
    } else {
      if (traverse->duplicates == 0) {
	traverse->duplicates = newmatch;
	if(!back) traverse->hasdupes = 1;

	break;
      }
    }

    back = traverse;
    traverse = traverse->duplicates;
  }
}


#ifndef NO_HARDLINKS
static inline void hardlinkfiles(file_t *files)
{
  static file_t *tmpfile;
  static file_t *curfile;
  static file_t ** restrict dupelist;
  static int counter;
  static int max = 0;
  static int x = 0;
  static int i;
  static char temp_path[4096];

  curfile = files;

  while (curfile) {
    if (curfile->hasdupes) {
      counter = 1;
      tmpfile = curfile->duplicates;
      while (tmpfile) {
       counter++;
       tmpfile = tmpfile->duplicates;
      }

      if (counter > max) max = counter;
    }

    curfile = curfile->next;
  }

  max++;

  dupelist = (file_t**) malloc(sizeof(file_t*) * max);

  if (!dupelist) errormsg(NULL);

  while (files) {
    if (files->hasdupes) {
      counter = 1;
      dupelist[counter] = files;

      tmpfile = files->duplicates;

      while (tmpfile) {
       counter++;
       dupelist[counter] = tmpfile;
       tmpfile = tmpfile->duplicates;
      }

      /* Link every file to the first file */

      if (!ISFLAG(flags, F_HIDEPROGRESS)) printf("[SRC] %s\n", dupelist[1]->d_name);
      for (x = 2; x <= counter; x++) {
        /* Can't hard link files on different devices */
        if (dupelist[1]->device != dupelist[x]->device) {
	  fprintf(stderr, "warning: hard link target on different device, not linking:\n-//-> %s\n",
		  dupelist[x]->d_name);
	  continue;
	} else {
          /* The devices for the files are the same, but we still need to skip
           * anything that is already hard linked (-L and -H both set) */
          if (dupelist[1]->inode == dupelist[x]->inode) {
            if (!ISFLAG(flags, F_HIDEPROGRESS)) printf("-==-> %s\n", dupelist[x]->d_name);
            continue;
          }
        }
        /* Do not attempt to hard link files for which we don't have write access */
	if (access(dupelist[x]->d_name, W_OK) != 0) {
	  fprintf(stderr, "warning: hard link target is a read-only file, not linking:\n-//-> %s\n",
		  dupelist[x]->d_name);
	  continue;
	}
        /* Safe hard linking: don't actually delete until the link succeeds */
        strcpy(temp_path, dupelist[x]->d_name);
        strcat(temp_path, "._fd_tmp");
        i = rename(dupelist[x]->d_name, temp_path);
        if (i != 0) {
	  fprintf(stderr, "warning: cannot move hard link target to a temporary name, not linking:\n-//-> %s\n",
		  dupelist[x]->d_name);
          continue;
        }

	errno = 0;
#ifdef ON_WINDOWS
        if (CreateHardLink(dupelist[x]->d_name, dupelist[1]->d_name, NULL) == TRUE) {
#else
        if (link(dupelist[1]->d_name, dupelist[x]->d_name) == 0) {
#endif /* ON_WINDOWS */
          if (!ISFLAG(flags, F_HIDEPROGRESS)) printf("----> %s\n", dupelist[x]->d_name);
        } else {
          /* The hard link failed. Warn the user and put the link target back */
          if (!ISFLAG(flags, F_HIDEPROGRESS)) printf("-//-> %s ", dupelist[x]->d_name);
	  fprintf(stderr, "warning: unable to hard link '%s' -> '%s': %s\n",
			  dupelist[x]->d_name, dupelist[1]->d_name, strerror(errno));
          i = rename(temp_path, dupelist[x]->d_name);
	  if (i != 0) {
		  fprintf(stderr, "error: cannot rename temp file back to original\n");
		  fprintf(stderr, "original: %s\n", dupelist[x]->d_name);
		  fprintf(stderr, "current:  %s\n", temp_path);
	  }
	  continue;
        }
        i = unlink(temp_path);
	if (i != 0) fprintf(stderr, "\nwarning: can't delete temp file: %s\n", temp_path);
      }
      if (!ISFLAG(flags, F_HIDEPROGRESS)) printf("\n");
    }
    files = files->next;
  }

  free(dupelist);
}
#endif /* NO_HARDLINKS */


static inline void help_text(void)
{
  printf("Usage: jdupes [options] DIRECTORY...\n\n");

  printf(" -r --recurse     \tfor every directory given follow subdirectories\n");
  printf("                  \tencountered within\n");
  printf(" -R --recurse:    \tfor each directory given after this option follow\n");
  printf("                  \tsubdirectories encountered within (note the ':' at\n");
  printf("                  \tthe end of the option, manpage for more details)\n");
#ifndef NO_SYMLINKS
  printf(" -s --symlinks    \tfollow symlinks\n");
#endif
#ifndef NO_HARDLINKS
  printf(" -H --hardlinks   \tnormally, when two or more files point to the same\n");
  printf("                  \tdisk area they are treated as non-duplicates; this\n");
  printf("                  \toption will change this behavior\n");
  printf(" -L --linkhard    \thard link duplicate files to the first file in\n");
  printf("                  \teach set of duplicates without prompting the user\n");
#endif
  printf(" -n --noempty     \texclude zero-length files from consideration\n");
  printf(" -x --xsize=SIZE  \texclude files of size < SIZE from consideration; the\n");
  printf("                  \tSIZE argument accepts 'K', 'M' and 'G' unit suffix\n");
  printf(" -A --nohidden    \texclude hidden files from consideration\n");
  printf(" -f --omitfirst   \tomit the first file in each set of matches\n");
  printf(" -1 --sameline    \tlist each set of matches on a single line\n");
  printf(" -S --size        \tshow size of duplicate files\n");
  printf(" -m --summarize   \tsummarize dupe information\n");
  printf(" -q --quiet       \thide progress indicator\n");
/* This is undocumented in the quick help because it is a dangerous option. If you
 * really want it, uncomment it here, and may your data rest in peace. */
/*  printf(" -Q --quick       \tskip byte-by-byte duplicate verification. WARNING:\n");
  printf("                  \tthis may delete non-duplicates! Read the manual first!\n"); */
  printf(" -d --delete      \tprompt user for files to preserve and delete all\n");
  printf("                  \tothers; important: under particular circumstances,\n");
  printf("                  \tdata may be lost when using this option together\n");
  printf("                  \twith -s or --symlinks, or when specifying a\n");
  printf("                  \tparticular directory more than once; refer to the\n");
  printf("                  \tdocumentation for additional information\n");
  printf(" -N --noprompt    \ttogether with --delete, preserve the first file in\n");
  printf("                  \teach set of duplicates and delete the rest without\n");
  printf("                  \tprompting the user\n");
#ifndef NO_PERMS
  printf(" -p --permissions \tdon't consider files with different owner/group or\n");
  printf("                  \tpermission bits as duplicates\n");
#endif
  printf(" -o --order=BY    \tselect sort order for output, linking and deleting; by\n");
  printf("                  \tmtime (BY=time; default) or filename (BY=name)\n");
  printf(" -O --paramorder  \tParameter order is more important than selected -O sort\n");
#ifdef HAVE_BTRFS_IOCTL_H
  printf(" -B --dedupe      \tSend matches to btrfs for block-level deduplication\n");
#endif
  printf(" -v --version     \tdisplay jdupes version and license information\n");
  printf(" -h --help        \tdisplay this help message\n\n");
#ifdef OMIT_GETOPT_LONG
  printf("Note: Long options are not supported in this build.\n\n");
#endif
}

int main(int argc, char **argv) {
  static file_t *files = NULL;
  static file_t *curfile;
  static char **oldargv;
  static char *endptr;
#ifndef USE_TREE_REBALANCE
    filetree_t *checktree = NULL;
#endif
  static int firstrecurse;
  static int opt;
  static ordertype_t ordertype = ORDER_TIME;

#ifndef OMIT_GETOPT_LONG
  static struct option long_options[] =
  {
    { "omitfirst", 0, 0, 'f' },
    { "recurse", 0, 0, 'r' },
    { "recursive", 0, 0, 'r' },
    { "recurse:", 0, 0, 'R' },
    { "recursive:", 0, 0, 'R' },
    { "quiet", 0, 0, 'q' },
    { "quick", 0, 0, 'Q' },
    { "sameline", 0, 0, '1' },
    { "size", 0, 0, 'S' },
#ifndef NO_SYMLINKS
    { "symlinks", 0, 0, 's' },
#endif
#ifndef NO_HARDLINKS
    { "hardlinks", 0, 0, 'H' },
    { "linkhard", 0, 0, 'L' },
#endif
    { "noempty", 0, 0, 'n' },
    { "xsize", 1, 0, 'x' },
    { "nohidden", 0, 0, 'A' },
    { "delete", 0, 0, 'd' },
    { "debug", 0, 0, 'D' },
    { "version", 0, 0, 'v' },
    { "help", 0, 0, 'h' },
    { "noprompt", 0, 0, 'N' },
    { "summarize", 0, 0, 'm'},
    { "summary", 0, 0, 'm' },
#ifndef NO_PERMS
    { "permissions", 0, 0, 'p' },
#endif
    { "paramorder", 0, 0, 'O' },
    { "order", 1, 0, 'o' },
    { "dedupe", 0, 0, 'B' },
    { 0, 0, 0, 0 }
  };
#define GETOPT getopt_long
#else
#define GETOPT getopt
#endif

  program_name = argv[0];

  oldargv = cloneargs(argc, argv);

  while ((opt = GETOPT(argc, argv,
  "frRqQ1SsHLnx:AdDvhNmpo:OB"
#ifndef OMIT_GETOPT_LONG
          , long_options, NULL
#endif
	  )) != EOF) {
    switch (opt) {
    case 'f':
      SETFLAG(flags, F_OMITFIRST);
      break;
    case 'r':
      SETFLAG(flags, F_RECURSE);
      break;
    case 'R':
      SETFLAG(flags, F_RECURSEAFTER);
      break;
    case 'q':
      SETFLAG(flags, F_HIDEPROGRESS);
      break;
    case 'Q':
      SETFLAG(flags, F_QUICKCOMPARE);
      break;
    case '1':
      SETFLAG(flags, F_DSAMELINE);
      break;
    case 'S':
      SETFLAG(flags, F_SHOWSIZE);
      break;
#ifndef NO_SYMLINKS
    case 's':
      SETFLAG(flags, F_FOLLOWLINKS);
      break;
#endif
#ifndef NO_HARDLINKS
    case 'H':
      SETFLAG(flags, F_CONSIDERHARDLINKS);
      break;
    case 'L':
      SETFLAG(flags, F_HARDLINKFILES);
      break;
#endif
    case 'n':
      SETFLAG(flags, F_EXCLUDEEMPTY);
      break;
    case 'x':
      SETFLAG(flags, F_EXCLUDESIZE);
      excludesize = strtoull(optarg, &endptr, 0);
      switch (*endptr) {
        case 'k':
	case 'K':
          excludesize = excludesize * 1024;
          endptr++;
          break;
        case 'm':
        case 'M':
          excludesize = excludesize * 1024 * 1024;
          endptr++;
          break;
        case 'g':
        case 'G':
          excludesize = excludesize * 1024 * 1024 * 1024;
          endptr++;
          break;
        default:
          break;
      }
      if (*endptr != '\0') {
        errormsg("invalid value for --xsize: '%s'\n", optarg);
        exit(EXIT_FAILURE);
      }
      break;
    case 'A':
      SETFLAG(flags, F_EXCLUDEHIDDEN);
      break;
    case 'd':
      SETFLAG(flags, F_DELETEFILES);
      break;
    case 'D':
#ifdef DEBUG
      SETFLAG(flags, F_DEBUG);
#endif
      break;
    case 'v':
      printf("jdupes %s (%s)\n", VER, VERDATE);
      printf("\nCompile-time extensions:");
      if (*extensions != NULL) {
	      int c = 0;
	      while (extensions[c] != NULL) {
		      printf(" %s", extensions[c]);
		      c++;
	      }
      } else printf(" none");
      printf("\n\nCopyright (C) 2015-2016 by Jody Bruchon\n");
      printf("Derived from 'fdupes' (C) 1999-2016 by Adrian Lopez\n");
      printf("Includes jody_hash (C) 2015-2016 by Jody Bruchon <jody@jodybruchon.com>\n\n");
#ifdef ON_WINDOWS
      printf("Ported to Windows (MinGW-w64) by Jody Bruchon\n");
#endif
      printf("Permission is hereby granted, free of charge, to any person\n");
      printf("obtaining a copy of this software and associated documentation files\n");
      printf("(the \"Software\"), to deal in the Software without restriction,\n");
      printf("including without limitation the rights to use, copy, modify, merge,\n");
      printf("publish, distribute, sublicense, and/or sell copies of the Software,\n");
      printf("and to permit persons to whom the Software is furnished to do so,\n");
      printf("subject to the following conditions:\n\n");
      printf("The above copyright notice and this permission notice shall be\n");
      printf("included in all copies or substantial portions of the Software.\n\n");
      printf("THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n");
      printf("OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n");
      printf("MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n");
      printf("IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n");
      printf("CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n");
      printf("TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n");
      printf("SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n");
      exit(EXIT_SUCCESS);
    case 'h':
      help_text();
      exit(EXIT_FAILURE);
    case 'N':
      SETFLAG(flags, F_NOPROMPT);
      break;
    case 'm':
      SETFLAG(flags, F_SUMMARIZEMATCHES);
      break;
    case 'p':
      SETFLAG(flags, F_PERMISSIONS);
      break;
    case 'O':
      SETFLAG(flags, F_USEPARAMORDER);
      break;
    case 'o':
      if (!strncasecmp("name", optarg, 5)) {
        ordertype = ORDER_NAME;
      } else if (!strncasecmp("time", optarg, 5)) {
        ordertype = ORDER_TIME;
      } else {
        errormsg("invalid value for --order: '%s'\n", optarg);
        exit(EXIT_FAILURE);
      }
      break;
    case 'B':
#ifdef HAVE_BTRFS_IOCTL_H
    SETFLAG(flags, F_DEDUPEFILES);
    /* btrfs will do the byte-for-byte check itself */
    SETFLAG(flags, F_QUICKCOMPARE);
#else
    errormsg("This program was built without btrfs support\n");
    exit(EXIT_FAILURE);
#endif
    break;

    default:
      fprintf(stderr, "Try `jdupes --help' for more information.\n");
      exit(EXIT_FAILURE);
    }
  }

  if (optind >= argc) {
    errormsg("no directories specified\n");
    exit(EXIT_FAILURE);
  }
  if (ISFLAG(flags, F_RECURSE) && ISFLAG(flags, F_RECURSEAFTER)) {
    errormsg("options --recurse and --recurse: are not compatible\n");
    exit(EXIT_FAILURE);
  }

  if (ISFLAG(flags, F_SUMMARIZEMATCHES) && ISFLAG(flags, F_DELETEFILES)) {
    errormsg("options --summarize and --delete are not compatible\n");
    exit(EXIT_FAILURE);
  }
  if (!!ISFLAG(flags, F_SUMMARIZEMATCHES) +
      !!ISFLAG(flags, F_DELETEFILES) +
      !!ISFLAG(flags, F_HARDLINKFILES) +
      !!ISFLAG(flags, F_DEDUPEFILES) > 1) {
      errormsg("Only one of --summarize, --delete, --linkhard or --dedupe may be used\n");
      exit(EXIT_FAILURE);
   }

  if (ISFLAG(flags, F_RECURSEAFTER)) {
    firstrecurse = nonoptafter("--recurse:", argc, oldargv, argv, optind);

    if (firstrecurse == argc)
      firstrecurse = nonoptafter("-R", argc, oldargv, argv, optind);

    if (firstrecurse == argc) {
      errormsg("-R option must be isolated from other options\n");
      exit(EXIT_FAILURE);
    }

    /* F_RECURSE is not set for directories before --recurse: */
    for (int x = optind; x < firstrecurse; x++) {
      grokdir(argv[x], &files);
      user_dir_count++;
    }

    /* Set F_RECURSE for directories after --recurse: */
    SETFLAG(flags, F_RECURSE);

    for (int x = firstrecurse; x < argc; x++) {
      grokdir(argv[x], &files);
      user_dir_count++;
    }
  } else {
    for (int x = optind; x < argc; x++) {
      grokdir(argv[x], &files);
      user_dir_count++;
    }
  }

//  if (!ISFLAG(flags, F_HIDEPROGRESS)) fprintf(stderr, "\r%60s\r", " ");
  if (!ISFLAG(flags, F_HIDEPROGRESS)) fprintf(stderr, "\n");
  if (!files) exit(EXIT_SUCCESS);

  curfile = files;

  while (curfile) {
    static uintmax_t progress = 0;
    static uintmax_t dupecount = 0;
    static file_t **match = NULL;
    static FILE *file1;
    static FILE *file2;
    static off_t delay = DELAY_COUNT;

    if (!checktree) registerfile(&checktree, NONE, curfile);
    else match = checkmatch(checktree, curfile);

#ifdef USE_TREE_REBALANCE
    /* Rebalance the match tree after a certain number of files processed */
    if ((progress & ((BAL_BIT << 1) - 1)) == BAL_BIT) rebalance_tree(checktree);
#endif /* USE_TREE_REBALANCE */

    /* Byte-for-byte check that a matched pair are actually matched */
    if (match != NULL) {
      /* Quick comparison mode will never run confirmmatch()
       * Also skip match confirmation for hard-linked files
       * (This set of comparisons is ugly, but quite efficient) */
      if (ISFLAG(flags, F_QUICKCOMPARE) ||
		(ISFLAG(flags, F_CONSIDERHARDLINKS) &&
		 (curfile->inode == (*match)->inode) &&
		 (curfile->device == (*match)->device))
		) {
        registerpair(match, curfile,
            (ordertype == ORDER_TIME) ? sort_pairs_by_mtime : sort_pairs_by_filename);
	dupecount++;
	goto skip_full_check;
      }

      file1 = fopen(curfile->d_name, "rb");
      if (!file1) {
	curfile = curfile->next;
	continue;
      }

      file2 = fopen((*match)->d_name, "rb");
      if (!file2) {
	fclose(file1);
	curfile = curfile->next;
	continue;
      }

      if (confirmmatch(file1, file2)) {
        registerpair(match, curfile,
            (ordertype == ORDER_TIME) ? sort_pairs_by_mtime : sort_pairs_by_filename);
	dupecount++;
      } DBG(else hash_fail++;)

      fclose(file1);
      fclose(file2);
    }

skip_full_check:
    curfile = curfile->next;

    if (!ISFLAG(flags, F_HIDEPROGRESS)) {
      /* If file size is larger than 1 MiB, make progress update faster
       * If confirmmatch() is run on a file, speed up progress even further */
      if (curfile != NULL) delay += (curfile->size >> 20);
      if (match != NULL) delay++;
      if ((delay >= DELAY_COUNT)) {
        delay = 0;
        fprintf(stderr, "\rProgress [%ju/%ju, %ju pairs matched] %ju%%", progress, filecount,
          dupecount, (progress * 100) / filecount);
      } else delay++;
    }
    progress++;
  }

  if (!ISFLAG(flags, F_HIDEPROGRESS)) fprintf(stderr, "\r%60s\r", " ");

  if (ISFLAG(flags, F_DELETEFILES)) {
    if (ISFLAG(flags, F_NOPROMPT)) deletefiles(files, 0, 0);
    else deletefiles(files, 1, stdin);
  } else {
#ifndef NO_HARDLINKS
    if (ISFLAG(flags, F_HARDLINKFILES)) {
      if (ISFLAG(flags, F_SUMMARIZEMATCHES)) summarizematches(files);
      hardlinkfiles(files);
    }
#else
    if (0) {}
#endif /* NO_HARDLINKS */
#ifdef HAVE_BTRFS_IOCTL_H
    else if (ISFLAG(flags, F_DEDUPEFILES)) dedupefiles(files);
#endif /* HAVE_BTRFS_IOCTL_H */
    else {
      if (ISFLAG(flags, F_SUMMARIZEMATCHES)) summarizematches(files);
      else printmatches(files);
    }
  }

  /*
  while (files) {
    curfile = files->next;
    free(files);
    files = curfile;
  }
  */

  purgetree(checktree);
  string_malloc_destroy();

#ifdef DEBUG
  if (ISFLAG(flags, F_DEBUG)) {
    fprintf(stderr, "\n%d partial (+%d small) -> %d full (%d partial elim) (%d hash fail)\n",
		partial_hash, small_file, partial_to_full,
		(partial_hash - partial_to_full), hash_fail);
    fprintf(stderr, "%ju total files, %ju comparisons, branch L %u, R %u, both %u\n",
		    filecount, comparisons, left_branch, right_branch,
		    left_branch + right_branch);
    fprintf(stderr, "Max tree depth: %u; SMA alloc: %ju, free: %ju\n",
		    max_depth, sma_allocs, sma_frees);
  }
#endif /* DEBUG */

  exit(EXIT_SUCCESS);

}
